// OpenAI client wrapper
const { OpenAI } = require('openai');

// Limit the prompt size to prevent exceeding model context limits
const MAX_HISTORY_LENGTH = 15000; // roughly a few thousand tokens

class OpenAIClient {
  constructor(apiKey) {
    this.client = new OpenAI({ apiKey });
  }

  async summarizeTicket(ticket, comments) {
    try {
      // Prepare the conversation history from ticket and comments
      const conversationHistory = this.prepareConversationHistory(ticket, comments);
      
      // Create the system prompt
      const systemPrompt = `You are a helpful assistant that summarizes Zendesk support tickets. 
Your task is to create a clear, concise summary of the ticket conversation that includes:
1. The main issue or request
2. Key points from the conversation
3. Current status or resolution
Keep the summary professional and focused on the most important information.`;

      const response = await this.client.chat.completions.create({
        model: "gpt-4-turbo-preview",
        messages: [
          { role: "system", content: systemPrompt },
          { 
            role: "user", 
            content: `Please summarize this support ticket conversation:\n\n${conversationHistory}`
          }
        ],
        temperature: 0.7,
        max_tokens: 500
      });

      return response.choices[0].message.content;
    } catch (error) {
      console.error('OpenAI API Error:', error);
      throw new Error('Failed to generate ticket summary');
    }
  }

  prepareConversationHistory(ticket, comments) {
    // Start with the ticket description
    let history = `TICKET #${ticket.id}: ${ticket.subject}\n`;
    history += `Status: ${ticket.status}\n`;
    history += `Priority: ${ticket.priority || 'not set'}\n\n`;
    history += `Initial Description:\n${ticket.description || 'No description provided'}\n\n`;

    // Add comments in chronological order
    if (comments && comments.length > 0) {
      history += 'Conversation:\n';
      for (const comment of comments.filter(c => c.public)) {
        const snippet = `---\nFrom: ${comment.author}\n${comment.body}\n`;
        if (history.length + snippet.length > MAX_HISTORY_LENGTH) {
          history += '... (truncated due to length)\n';
          break;
        }
        history += snippet;
      }
    }

    return history;
  }

  async generateSummaryBlocks(ticket, summary) {
    return [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `üìù Summary of Ticket #${ticket.id}`,
          emoji: true
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Original Subject:* ${ticket.subject}`
        }
      },
      {
        type: 'divider'
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: summary
        }
      },
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `üí° _This summary was generated by AI and may not capture all details. <${ticket.url}|View the full ticket in Zendesk>_`
          }
        ]
      }
    ];
  }
}

module.exports = OpenAIClient;
module.exports.MAX_HISTORY_LENGTH = MAX_HISTORY_LENGTH;
